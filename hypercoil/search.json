[
  {
    "objectID": "api/hypercoil.functional.activation.corrnorm.html",
    "href": "api/hypercoil.functional.activation.corrnorm.html",
    "title": "corrnorm",
    "section": "",
    "text": "[source]\n\nfunctional.activation.corrnorm(\n    input: Tensor\n    factor: Optional[Union[Tensor, Tuple[Tensor, Tensor]]] = None\n    gradpath: Literal['input', 'both'] = 'both'\n)\nCorrelation normalisation activation function.\nDivide each entry :math:A_{ij} of the input matrix :math:A by the product of the signed square roots of the corresponding diagonals:\n:math:\\bar{A}_{ij} = A_{ij} \\frac{\\mathrm{sgn}(A_{ii} A_{jj})}{\\sqrt{A_{ii}}\\sqrt{A_{jj}} + \\epsilon}\nThis default behaviour, which maps a covariance matrix to a Pearson correlation matrix, can be overriden by providing a factor argument (detailed below). This activation function is also similar to a signed version of the normalisation operation for a graph Laplacian matrix.\n:Dimension: input : :math:(*, P, P) P denotes the row and column dimensions of the input matrices. * denotes any number of additional dimensions. output : :math:(*, P, P) As above.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nTensor\nTensor to be normalised.\nrequired\n\n\nfactor\nTensor, iterable(Tensor, Tensor), or None (default None)\nNormalisation factor. * If this is not explicitly specified, it follows the default behaviour (division by the product of signed square roots.) * If this is a tensor, input is directly divided by the provided tensor. This option is provided mostly for compatibility with non-square inputs. * If this is a pair of tensors, then input is divided by their outer product.\nNone\n\n\ngradpath\nstr \\'input\\' or \\'both\\' (default \\'both\\')\nIf this is set to 'input' and the default normalisation behaviour is used, then gradient will be blocked from flowing backward through the computation of the normalisation factor from the input.\n'both'\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTensor\nNormalised input.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "corrnorm"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.corrnorm.html#parameters",
    "href": "api/hypercoil.functional.activation.corrnorm.html#parameters",
    "title": "corrnorm",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ninput\nTensor\nTensor to be normalised.\nrequired\n\n\nfactor\nTensor, iterable(Tensor, Tensor), or None (default None)\nNormalisation factor. * If this is not explicitly specified, it follows the default behaviour (division by the product of signed square roots.) * If this is a tensor, input is directly divided by the provided tensor. This option is provided mostly for compatibility with non-square inputs. * If this is a pair of tensors, then input is divided by their outer product.\nNone\n\n\ngradpath\nstr \\'input\\' or \\'both\\' (default \\'both\\')\nIf this is set to 'input' and the default normalisation behaviour is used, then gradient will be blocked from flowing backward through the computation of the normalisation factor from the input.\n'both'",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "corrnorm"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.corrnorm.html#returns",
    "href": "api/hypercoil.functional.activation.corrnorm.html#returns",
    "title": "corrnorm",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nTensor\nNormalised input.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "corrnorm"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.amplitude_tanh.html",
    "href": "api/hypercoil.functional.activation.amplitude_tanh.html",
    "title": "amplitude_tanh",
    "section": "",
    "text": "[source]\n\nfunctional.activation.amplitude_tanh(input: Tensor)\nHyperbolic tangent activation function applied to the amplitude only.\nThe amplitude (absolute value) of the input is transformed according to\n:math:\\mathrm{tanh} x\nwhile the phase (complex argument) is preserved. This function maps the complex plane to the open unit disc: the origin is mapped to itself and distant regions of the complex plane are mapped to the circumference.\n:Dimension: As this activation function is applied elementwise, it conserves dimension; the output will be of the same shape as the input.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nTensor\nTensor whose amplitude is to be transformed elementwise by the hyperbolic tangent activation function.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nout\nTensor\nTransformed input tensor.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "amplitude_tanh"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.amplitude_tanh.html#parameters",
    "href": "api/hypercoil.functional.activation.amplitude_tanh.html#parameters",
    "title": "amplitude_tanh",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ninput\nTensor\nTensor whose amplitude is to be transformed elementwise by the hyperbolic tangent activation function.\nrequired",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "amplitude_tanh"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.amplitude_tanh.html#returns",
    "href": "api/hypercoil.functional.activation.amplitude_tanh.html#returns",
    "title": "amplitude_tanh",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nout\nTensor\nTransformed input tensor.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "amplitude_tanh"
    ]
  },
  {
    "objectID": "api/connectopy.html",
    "href": "api/connectopy.html",
    "title": "connectopy",
    "section": "",
    "text": "functional.connectopy\nConnectopic manifold mapping, based on brainspace.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ndiffusion_mapping\nManifold coordinates estimated using diffusion mapping.\n\n\nlaplacian_eigenmaps\nManifold coordinates estimated using Laplacian eigenmaps.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "connectopy",
      "connectopy"
    ]
  },
  {
    "objectID": "api/connectopy.html#functions",
    "href": "api/connectopy.html#functions",
    "title": "connectopy",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ndiffusion_mapping\nManifold coordinates estimated using diffusion mapping.\n\n\nlaplacian_eigenmaps\nManifold coordinates estimated using Laplacian eigenmaps.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "connectopy",
      "connectopy"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.amplitude_expbarrier.html",
    "href": "api/hypercoil.functional.activation.amplitude_expbarrier.html",
    "title": "amplitude_expbarrier",
    "section": "",
    "text": "[source]\n\nfunctional.activation.amplitude_expbarrier(\n    input: Tensor\n    barrier: Union[float, Tensor] = 1\n)\nExponential barrier activation function applied to the amplitude only.\nThe amplitude (absolute value) of the input is transformed according to\n:math:b \\sqrt{1 - \\exp{\\frac{-|x|}{b^2}}}\nwhile the phase (complex argument) is preserved. This function maps the complex plane to the open unit disc: the origin is mapped to itself and distant regions of the complex plane are mapped to the circumference.\n:Dimension: As this activation function is applied elementwise, it conserves dimension; the output will be of the same shape as the input.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nTensor\nTensor whose amplitude is to be transformed elementwise by the double exponential activation function.\nrequired\n\n\nbarrier\nfloat or broadcastable Tensor (default 0)\nBarrier parameter b of the exponential function.\n1\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nout\nTensor\nTransformed input tensor.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "amplitude_expbarrier"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.amplitude_expbarrier.html#parameters",
    "href": "api/hypercoil.functional.activation.amplitude_expbarrier.html#parameters",
    "title": "amplitude_expbarrier",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ninput\nTensor\nTensor whose amplitude is to be transformed elementwise by the double exponential activation function.\nrequired\n\n\nbarrier\nfloat or broadcastable Tensor (default 0)\nBarrier parameter b of the exponential function.\n1",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "amplitude_expbarrier"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.amplitude_expbarrier.html#returns",
    "href": "api/hypercoil.functional.activation.amplitude_expbarrier.html#returns",
    "title": "amplitude_expbarrier",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nout\nTensor\nTransformed input tensor.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "amplitude_expbarrier"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.isochor.html",
    "href": "api/hypercoil.functional.activation.isochor.html",
    "title": "isochor",
    "section": "",
    "text": "[source]\n\nfunctional.activation.isochor(\n    input: Tensor\n    volume: float = 1\n    max_condition: Optional[float] = None\n    softmax_temp: Optional[float] = None\n)\nVolume-normalising activation function for symmetric, positive definite matrices.\nThis activation function first finds the eigendecomposition of each input matrix. The eigenvalues are then each divided by :math:\\sqrt[n]{\\frac{v_{in}}{v_{target}}} to normalise the determinant to :math:v_{target}. Before normalisation, there are options to rescale the eigenvalues through a softmax and/or to enforce a maximal condition number for the output tensor. If the input tensors are being used to represent ellipsoids, for instance, this can constrain the eccentricity of those ellipsoids. Finally, the matrix is reconstituted using the original eigenvectors and the rescaled eigenvalues.\n:Dimension: input : :math:(*, P, P) P denotes the row and column dimensions of the input matrices. * denotes any number of additional dimensions. output : :math:(*, P, P) As above.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\ntensor\nTensor containing symmetric, positive definite matrices.\nrequired\n\n\nvolume\nfloat (default 1)\nTarget volume for the normalisation procedure. All output tensors will have this determinant.\n1\n\n\nmax_condition\nfloat :math:\\in \\[1, \\infty) or None (default None)\nMaximum permissible condition number among output tensors. This can be used to constrain the eccentricity of isochoric ellipsoids. To enforce this maximum, the eigenvalues of the input tensors are replaced with a convex combination of the original eigenvalues and a vector of ones such that the largest eigenvalue is no more than max_condition times the smallest eigenvalue. Note that a max_condition of 1 will always return (a potentially isotropically scaled) identity.\nNone\n\n\nsoftmax_temp\nfloat or None (default None)\nIf this is provided, then the eigenvalues of the input tensor are passed through a softmax with the specified temperature before any other processing.\nNone\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\ntensor\nVolume-normalised tensor.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "isochor"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.isochor.html#parameters",
    "href": "api/hypercoil.functional.activation.isochor.html#parameters",
    "title": "isochor",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ninput\ntensor\nTensor containing symmetric, positive definite matrices.\nrequired\n\n\nvolume\nfloat (default 1)\nTarget volume for the normalisation procedure. All output tensors will have this determinant.\n1\n\n\nmax_condition\nfloat :math:\\in \\[1, \\infty) or None (default None)\nMaximum permissible condition number among output tensors. This can be used to constrain the eccentricity of isochoric ellipsoids. To enforce this maximum, the eigenvalues of the input tensors are replaced with a convex combination of the original eigenvalues and a vector of ones such that the largest eigenvalue is no more than max_condition times the smallest eigenvalue. Note that a max_condition of 1 will always return (a potentially isotropically scaled) identity.\nNone\n\n\nsoftmax_temp\nfloat or None (default None)\nIf this is provided, then the eigenvalues of the input tensor are passed through a softmax with the specified temperature before any other processing.\nNone",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "isochor"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.isochor.html#returns",
    "href": "api/hypercoil.functional.activation.isochor.html#returns",
    "title": "isochor",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\ntensor\nVolume-normalised tensor.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "isochor"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.connectopy.diffusion_mapping.html",
    "href": "api/hypercoil.functional.connectopy.diffusion_mapping.html",
    "title": "diffusion_mapping",
    "section": "",
    "text": "[source]\n\nfunctional.connectopy.diffusion_mapping(\n    W: Tensor\n    k: int = 10\n    alpha: float = 0.5\n    diffusion_time: int = 0\n)\nManifold coordinates estimated using diffusion mapping.\nThis functionality is adapted very closely from brainspace with some minor adaptations for differentiability.\n.. warning::\nSparse inputs are currently unsupported because an implementation of a\nsparse extremal eigenvalue solver does not yet exist in JAX. For\nsparse inputs, use the generalised connectopic functional instead --\nonce we implement VJP rules for elementary operations on sparse\nmatrices, anyway.\n.. note::\nThe anisotropic diffusion parameter determines the kind of diffusion\nmap produced by the algorithm.\n\n* :math:`\\alpha = 0` produces Laplacian eigenmaps, corresponding to a\n  random walk-style diffusion operator.\n* :math:`\\alpha = 0.5` (default) corresponds to Fokker-Planck\n  diffusion.\n* :math:`\\alpha = 1` corresponds to Laplace-Beltrami diffusion.\n:Dimension: W : :math:(*, N, N) or :math:(*, E) * denotes any number of preceding dimensions, N denotes number of vertices, and E denotes number of edges. The shape should be :math:(*, N, N) if edge_index is not provided and :math:(*, E) if edge_index is provided. edge_index : :math:(*, 2, E) As above. Q : :math:(*, N, k) k denotes the number of diffusion maps. L : :math:(*, k) As above.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nW\ntensor\nEdge weight tensor. This should be the graph adjacency (or affinity) matrix.\nrequired\n\n\nk\nint (default 10)\nNumber of eigenmaps to compute.\n10\n\n\nalpha\nfloat :math:\\in \\[0, 1\\] (default 0.5)\nAnisotropic diffusion parameter.\n0.5\n\n\ndiffusion_time\nint (default 0)\nDiffusion time parameter. A value of 0 indicates that a multi-scale diffusion map should be computed, which considers all valid times (1, 2, 3, etc.).\n0\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nQ\ntensor\nDiffusion maps.\n\n\nL\ntensor\nEigenvalues corresponding to diffusion maps.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "connectopy",
      "diffusion_mapping"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.connectopy.diffusion_mapping.html#parameters",
    "href": "api/hypercoil.functional.connectopy.diffusion_mapping.html#parameters",
    "title": "diffusion_mapping",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nW\ntensor\nEdge weight tensor. This should be the graph adjacency (or affinity) matrix.\nrequired\n\n\nk\nint (default 10)\nNumber of eigenmaps to compute.\n10\n\n\nalpha\nfloat :math:\\in \\[0, 1\\] (default 0.5)\nAnisotropic diffusion parameter.\n0.5\n\n\ndiffusion_time\nint (default 0)\nDiffusion time parameter. A value of 0 indicates that a multi-scale diffusion map should be computed, which considers all valid times (1, 2, 3, etc.).\n0",
    "crumbs": [
      "`functional`: Functions and functionals",
      "connectopy",
      "diffusion_mapping"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.connectopy.diffusion_mapping.html#returns",
    "href": "api/hypercoil.functional.connectopy.diffusion_mapping.html#returns",
    "title": "diffusion_mapping",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nQ\ntensor\nDiffusion maps.\n\n\nL\ntensor\nEigenvalues corresponding to diffusion maps.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "connectopy",
      "diffusion_mapping"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.cmass.cmass_coor.html",
    "href": "api/hypercoil.functional.cmass.cmass_coor.html",
    "title": "cmass_coor",
    "section": "",
    "text": "[source]\n\nfunctional.cmass.cmass_coor(\n    X: Tensor\n    coor: Tensor\n    radius: Optional[float] = None\n)\nDifferentiably compute a weight’s centre of mass.\n:Dimension: Input : :math:(*, W, L) * denotes any number of preceding dimensions, W denotes number of weights (e.g., regions of an atlas), and L denotes number of locations (e.g., voxels). coor : :math:(*, D, L) D denotes the dimension of the embedding space of the locations.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nX\nTensor\nWeight whose centre of mass is to be computed.\nrequired\n\n\ncoor\nTensor\nCoordinates corresponding to each column (location/voxel) in X.\nrequired\n\n\nradius\nfloat or None (default None)\nIf this is not None, then the computed centre of mass is projected onto a sphere with the specified radius.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nTensor\nTensor containing the coordinates of the centre of mass of each row of input X. Coordinates are ordered as in the second-to-last axis of coor.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "cmass",
      "cmass_coor"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.cmass.cmass_coor.html#parameters",
    "href": "api/hypercoil.functional.cmass.cmass_coor.html#parameters",
    "title": "cmass_coor",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nX\nTensor\nWeight whose centre of mass is to be computed.\nrequired\n\n\ncoor\nTensor\nCoordinates corresponding to each column (location/voxel) in X.\nrequired\n\n\nradius\nfloat or None (default None)\nIf this is not None, then the computed centre of mass is projected onto a sphere with the specified radius.\nNone",
    "crumbs": [
      "`functional`: Functions and functionals",
      "cmass",
      "cmass_coor"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.cmass.cmass_coor.html#returns",
    "href": "api/hypercoil.functional.cmass.cmass_coor.html#returns",
    "title": "cmass_coor",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nTensor\nTensor containing the coordinates of the centre of mass of each row of input X. Coordinates are ordered as in the second-to-last axis of coor.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "cmass",
      "cmass_coor"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.cmass.cmass.html",
    "href": "api/hypercoil.functional.cmass.cmass.html",
    "title": "cmass",
    "section": "",
    "text": "[source]\n\nfunctional.cmass.cmass(\n    X: Tensor\n    axes: Optional[Sequence[int]] = None\n    na_rm: bool = False\n)\nDifferentiably compute a weight’s centre of mass. This can be used to regularise the weight so that its centre of mass is close to a provided coordinate.\n:Dimension: Input : :math:(*, k_1, k_2, ..., k_n) * denotes any number of batch and intervening dimensions, and the k_is are dimensions along which the centre of mass is computed Output : :math:(*, n) n denotes the number of dimensions of each centre of mass vector\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nX\nTensor\nTensor containing the weights whose centres of mass are to be computed.\nrequired\n\n\naxes\niterable or None (default None)\nAxes of the input tensor that together define each slice of the tensor within which a single centre-of-mass vector is computed. If this is set to None, then the centre of mass is computed across all axes. If this is [-3, -2, -1], then the centre of mass is computed separately for each 3-dimensional slice spanned by the last three axes of the tensor.\nNone\n\n\nna_rm\nfloat or False (default False)\nIf any single slice of the input tensor has zero mass, then the centre of mass within that slice is undefined and populated with NaN. The na_rm parameter specified how such undefined values are handled. If this is False, then NaN values are left intact; if this is a float, then NaN values are replaced by the specified float.\nFalse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\ncmass\nTensor\nCentre of mass vectors for each slice from the input tensor. The coordinates are ordered according to the specification in axes.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "cmass",
      "cmass"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.cmass.cmass.html#parameters",
    "href": "api/hypercoil.functional.cmass.cmass.html#parameters",
    "title": "cmass",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nX\nTensor\nTensor containing the weights whose centres of mass are to be computed.\nrequired\n\n\naxes\niterable or None (default None)\nAxes of the input tensor that together define each slice of the tensor within which a single centre-of-mass vector is computed. If this is set to None, then the centre of mass is computed across all axes. If this is [-3, -2, -1], then the centre of mass is computed separately for each 3-dimensional slice spanned by the last three axes of the tensor.\nNone\n\n\nna_rm\nfloat or False (default False)\nIf any single slice of the input tensor has zero mass, then the centre of mass within that slice is undefined and populated with NaN. The na_rm parameter specified how such undefined values are handled. If this is False, then NaN values are left intact; if this is a float, then NaN values are replaced by the specified float.\nFalse",
    "crumbs": [
      "`functional`: Functions and functionals",
      "cmass",
      "cmass"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.cmass.cmass.html#returns",
    "href": "api/hypercoil.functional.cmass.cmass.html#returns",
    "title": "cmass",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\ncmass\nTensor\nCentre of mass vectors for each slice from the input tensor. The coordinates are ordered according to the specification in axes.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "cmass",
      "cmass"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.amplitude_laplace.html",
    "href": "api/hypercoil.functional.activation.amplitude_laplace.html",
    "title": "amplitude_laplace",
    "section": "",
    "text": "[source]\n\nfunctional.activation.amplitude_laplace(\n    input: Tensor\n    loc: Union[float, Tensor] = 0\n    width: Union[float, Tensor] = 1\n)\nDouble exponential activation function applied to the amplitude only.\nThe amplitude (absolute value) of the input is transformed according to\n:math:e^{\\frac{-|x - \\mu|}{b}}\nwhile the phase (complex argument) is preserved. This function maps the complex plane to the open unit disc: the origin is mapped to the perimeter and distant regions of the complex plane are mapped to the origin. The function varies quickly near the origin (the region of the plane mapped close to the perimeter and small gradient updates could result in large changes in output. Furthermore, the function is completely discontinuous and undefined at the origin (the direction is ambiguous and any point in the circumference is equally valid).\n:Dimension: As this activation function is applied elementwise, it conserves dimension; the output will be of the same shape as the input.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nTensor\nTensor whose amplitude is to be transformed elementwise by the double exponential activation function.\nrequired\n\n\nloc\nfloat or broadcastable Tensor (default 0)\nCentre parameter :math:\\mu of the double exponential function.\n0\n\n\nwidth\nfloat or broadcastable Tensor (default 1)\nSpread parameter b of the double exponential function.\n1\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nout\nTensor\nTransformed input tensor.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "amplitude_laplace"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.amplitude_laplace.html#parameters",
    "href": "api/hypercoil.functional.activation.amplitude_laplace.html#parameters",
    "title": "amplitude_laplace",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ninput\nTensor\nTensor whose amplitude is to be transformed elementwise by the double exponential activation function.\nrequired\n\n\nloc\nfloat or broadcastable Tensor (default 0)\nCentre parameter :math:\\mu of the double exponential function.\n0\n\n\nwidth\nfloat or broadcastable Tensor (default 1)\nSpread parameter b of the double exponential function.\n1",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "amplitude_laplace"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.amplitude_laplace.html#returns",
    "href": "api/hypercoil.functional.activation.amplitude_laplace.html#returns",
    "title": "amplitude_laplace",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nout\nTensor\nTransformed input tensor.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "amplitude_laplace"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.cmass.diffuse.html",
    "href": "api/hypercoil.functional.cmass.diffuse.html",
    "title": "diffuse",
    "section": "",
    "text": "[source]\n\nfunctional.cmass.diffuse(\n    X: Tensor\n    coor: Tensor\n    norm: Any = 2\n    floor: float = 0\n    radius: Optional[float] = None\n)\nCompute a compactness score for a weight.\nThe compactness is defined as\n:math:\\mathbf{1}^\\intercal\\left(A \\circ \\left\\|C - \\frac{AC}{A\\mathbf{1}} \\right\\|_{cols} \\right)\\mathbf{1}\n:Dimension: Input : :math:(*, W, L) * denotes any number of preceding dimensions, W denotes number of weights (e.g., regions of an atlas), and L denotes number of locations (e.g., voxels). coor : :math:(*, D, L) D denotes the dimension of the embedding space of the locations.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nX\nTensor\nWeight for which the compactness score is to be computed.\nrequired\n\n\ncoor\nTensor\nCoordinates corresponding to each column (location/voxel) in X.\nrequired\n\n\nnorm\nAny\nIndicator of the type of norm to use for the distance function.\n2\n\n\nfloor\nfloat (default 0)\nAny points closer to the centre of mass than the floor are assigned a compactness score of 0.\n0\n\n\nradius\nfloat or None (default None)\nIf this is not None, then the centre of mass and distances are computed on a sphere with the specified radius.\nNone\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\n\nfloat\nMeasure of each weight’s compactness about its centre of mass.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "cmass",
      "diffuse"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.cmass.diffuse.html#parameters",
    "href": "api/hypercoil.functional.cmass.diffuse.html#parameters",
    "title": "diffuse",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nX\nTensor\nWeight for which the compactness score is to be computed.\nrequired\n\n\ncoor\nTensor\nCoordinates corresponding to each column (location/voxel) in X.\nrequired\n\n\nnorm\nAny\nIndicator of the type of norm to use for the distance function.\n2\n\n\nfloor\nfloat (default 0)\nAny points closer to the centre of mass than the floor are assigned a compactness score of 0.\n0\n\n\nradius\nfloat or None (default None)\nIf this is not None, then the centre of mass and distances are computed on a sphere with the specified radius.\nNone",
    "crumbs": [
      "`functional`: Functions and functionals",
      "cmass",
      "diffuse"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.cmass.diffuse.html#returns",
    "href": "api/hypercoil.functional.cmass.diffuse.html#returns",
    "title": "diffuse",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\n\nfloat\nMeasure of each weight’s compactness about its centre of mass.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "cmass",
      "diffuse"
    ]
  },
  {
    "objectID": "api/cmass.html",
    "href": "api/cmass.html",
    "title": "cmass",
    "section": "",
    "text": "functional.cmass\nDifferentiably compute a weight’s centre of mass.\nFunctionality is available that operates on the “intrinsic” mesh grid coordinates of a tensor (:func:cmass, :func:cmass_reference_displacement_grid) or that takes the last axis of a tensor to correspond to different locations and accepts a second argument that indicates explicitly the coordinates of each location (:func:cmass_coor, :func:diffuse, :func:cmass_reference_displacement).\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\ncmass\nDifferentiably compute a weight’s centre of mass. This can be used to regularise the weight so that its centre of mass is close to a provided coordinate.\n\n\ncmass_coor\nDifferentiably compute a weight’s centre of mass.\n\n\ncmass_reference_displacement\nDisplacement of centres of mass from reference points – explicit coordinate version.\n\n\ncmass_reference_displacement_grid\nDisplacement of centres of mass from reference points – grid version.\n\n\ndiffuse\nCompute a compactness score for a weight.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "cmass",
      "cmass"
    ]
  },
  {
    "objectID": "api/cmass.html#functions",
    "href": "api/cmass.html#functions",
    "title": "cmass",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\ncmass\nDifferentiably compute a weight’s centre of mass. This can be used to regularise the weight so that its centre of mass is close to a provided coordinate.\n\n\ncmass_coor\nDifferentiably compute a weight’s centre of mass.\n\n\ncmass_reference_displacement\nDisplacement of centres of mass from reference points – explicit coordinate version.\n\n\ncmass_reference_displacement_grid\nDisplacement of centres of mass from reference points – grid version.\n\n\ndiffuse\nCompute a compactness score for a weight.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "cmass",
      "cmass"
    ]
  },
  {
    "objectID": "api/cov.html",
    "href": "api/cov.html",
    "title": "cov",
    "section": "",
    "text": "[source]\n\nfunctional.cov(\n    X: Tensor\n    rowvar: bool = True\n    bias: bool = False\n    ddof: Optional[int] = None\n    weight: Optional[Tensor] = None\n    l2: float = 0\n)\nEmpirical covariance of variables in a tensor batch.\n:Dimension: Input : :math:(N, *, C, obs) or :math:(N, *, obs, C) N denotes batch size, * denotes any number of intervening dimensions, C denotes number of data channels or variables to be correlated, obs denotes number of observations per channel Weight : :math:(obs) or :math:(obs, obs) As above Output : :math:(N, *, C, C) As above\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nX\nTensor\nTensor containing a sample of multivariate observations. Each slice along the last axis corresponds to an observation, and each slice along the penultimate axis corresponds to a data channel or more generally a variable.\nrequired\n\n\nrowvar\nbool (default True)\nIndicates that the last axis of the input tensor is the observation axis and the penultimate axis is the variable axis. If False, then this relationship is transposed.\nTrue\n\n\nbias\nbool (default False)\nIndicates that the biased normalisation (i.e., division by N in the unweighted case) should be performed. By default, normalisation of the covariance is unbiased (i.e., division by N - 1).\nFalse\n\n\nddof\nint or None (default None)\nDegrees of freedom for normalisation. If this is specified, it overrides the normalisation factor automatically determined using the bias parameter.\nNone\n\n\nweight\nTensor or None (default None)\nTensor containing importance or coupling weights for the observations. If this tensor is 1-dimensional, each entry weights the corresponding observation in the covariance computation. If it is 2-dimensional, then it must be square, symmetric, and positive semidefinite. In this case, diagonal entries again correspond to relative importances, while off-diagonal entries indicate coupling factors. For instance, a banded or multi-diagonal tensor can be used to specify inter-temporal coupling for a time series covariance.\nNone\n\n\nl2\nnonnegative float (default 0)\nL2 regularisation term to add to the maximum likelihood estimate of the covariance matrix. This can be set to a positive value to obtain an intermediate for estimating the regularised inverse covariance.\n0\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nsigma\nTensor\nEmpirical covariance matrix of the variables in the input tensor.\n\n\n\n\n\n\npairedcov : Covariance among variables in 2 tensors corr: Normalised covariance matrix (Pearson correlation matrix) precision: Inverse covariance (precision) matrix partialcorr: Partial correlation matrix",
    "crumbs": [
      "`functional`: Functions and functionals",
      "cov"
    ]
  },
  {
    "objectID": "api/cov.html#parameters",
    "href": "api/cov.html#parameters",
    "title": "cov",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nX\nTensor\nTensor containing a sample of multivariate observations. Each slice along the last axis corresponds to an observation, and each slice along the penultimate axis corresponds to a data channel or more generally a variable.\nrequired\n\n\nrowvar\nbool (default True)\nIndicates that the last axis of the input tensor is the observation axis and the penultimate axis is the variable axis. If False, then this relationship is transposed.\nTrue\n\n\nbias\nbool (default False)\nIndicates that the biased normalisation (i.e., division by N in the unweighted case) should be performed. By default, normalisation of the covariance is unbiased (i.e., division by N - 1).\nFalse\n\n\nddof\nint or None (default None)\nDegrees of freedom for normalisation. If this is specified, it overrides the normalisation factor automatically determined using the bias parameter.\nNone\n\n\nweight\nTensor or None (default None)\nTensor containing importance or coupling weights for the observations. If this tensor is 1-dimensional, each entry weights the corresponding observation in the covariance computation. If it is 2-dimensional, then it must be square, symmetric, and positive semidefinite. In this case, diagonal entries again correspond to relative importances, while off-diagonal entries indicate coupling factors. For instance, a banded or multi-diagonal tensor can be used to specify inter-temporal coupling for a time series covariance.\nNone\n\n\nl2\nnonnegative float (default 0)\nL2 regularisation term to add to the maximum likelihood estimate of the covariance matrix. This can be set to a positive value to obtain an intermediate for estimating the regularised inverse covariance.\n0",
    "crumbs": [
      "`functional`: Functions and functionals",
      "cov"
    ]
  },
  {
    "objectID": "api/cov.html#returns",
    "href": "api/cov.html#returns",
    "title": "cov",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nsigma\nTensor\nEmpirical covariance matrix of the variables in the input tensor.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "cov"
    ]
  },
  {
    "objectID": "api/cov.html#see-also",
    "href": "api/cov.html#see-also",
    "title": "cov",
    "section": "",
    "text": "pairedcov : Covariance among variables in 2 tensors corr: Normalised covariance matrix (Pearson correlation matrix) precision: Inverse covariance (precision) matrix partialcorr: Partial correlation matrix",
    "crumbs": [
      "`functional`: Functions and functionals",
      "cov"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.laplace.html",
    "href": "api/hypercoil.functional.activation.laplace.html",
    "title": "laplace",
    "section": "",
    "text": "[source]\n\nfunctional.activation.laplace(\n    input: Tensor\n    loc: Union[float, Tensor] = 0\n    width: Union[float, Tensor] = 1\n)\nDouble exponential activation function.\nThe double exponential activation function is applied elementwise as\n:math:e^{\\frac{-|x - \\mu|}{b}}\nto inputs x with centre :math:\\mu and width b. It constrains its outputs to the range (0, 1], mapping values closer to its centre to larger outputs. It is Lipschitz continuous over the reals and differentiable except at its centre.\n:Dimension: As this activation function is applied elementwise, it conserves dimension; the output will be of the same shape as the input.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nTensor\nTensor to be transformed elementwise by the double exponential activation function.\nrequired\n\n\nloc\nfloat or broadcastable Tensor (default 0)\nCentre parameter :math:\\mu of the double exponential function.\n0\n\n\nwidth\nfloat or broadcastable Tensor (default 1)\nSpread parameter b of the double exponential function.\n1\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nout\nTensor\nTransformed input tensor.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "laplace"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.laplace.html#parameters",
    "href": "api/hypercoil.functional.activation.laplace.html#parameters",
    "title": "laplace",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ninput\nTensor\nTensor to be transformed elementwise by the double exponential activation function.\nrequired\n\n\nloc\nfloat or broadcastable Tensor (default 0)\nCentre parameter :math:\\mu of the double exponential function.\n0\n\n\nwidth\nfloat or broadcastable Tensor (default 1)\nSpread parameter b of the double exponential function.\n1",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "laplace"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.laplace.html#returns",
    "href": "api/hypercoil.functional.activation.laplace.html#returns",
    "title": "laplace",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nout\nTensor\nTransformed input tensor.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "laplace"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.expbarrier.html",
    "href": "api/hypercoil.functional.activation.expbarrier.html",
    "title": "expbarrier",
    "section": "",
    "text": "[source]\n\nfunctional.activation.expbarrier(\n    input: Tensor\n    barrier: Union[float, Tensor] = 1\n)\nExponential barrier activation function.\nThe exponential barrier activation function is applied elementwise as\n:math:b \\sqrt{1 - \\exp{\\frac{-|x|}{b^2}}}\nto inputs x with barrier b. It constrains its outputs to the range [0, b). It is Lipschitz continuous over the reals and differentiable except at its centre.\n:Dimension: As this activation function is applied elementwise, it conserves dimension; the output will be of the same shape as the input.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nTensor\nTensor to be transformed elementwise by the exponential barrier activation function.\nrequired\n\n\nbarrier\nfloat or broadcastable Tensor (default 0)\nBarrier parameter b of the exponential function.\n1\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nout\nTensor\nTransformed input tensor.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "expbarrier"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.expbarrier.html#parameters",
    "href": "api/hypercoil.functional.activation.expbarrier.html#parameters",
    "title": "expbarrier",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ninput\nTensor\nTensor to be transformed elementwise by the exponential barrier activation function.\nrequired\n\n\nbarrier\nfloat or broadcastable Tensor (default 0)\nBarrier parameter b of the exponential function.\n1",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "expbarrier"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.expbarrier.html#returns",
    "href": "api/hypercoil.functional.activation.expbarrier.html#returns",
    "title": "expbarrier",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nout\nTensor\nTransformed input tensor.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "expbarrier"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.amplitude_atanh.html",
    "href": "api/hypercoil.functional.activation.amplitude_atanh.html",
    "title": "amplitude_atanh",
    "section": "",
    "text": "[source]\n\nfunctional.activation.amplitude_atanh(input: Tensor)\nInverse hyperbolic tangent (hyperbolic arctangent) activation function applied to the amplitude only.\nThe amplitude (absolute value) of the input is transformed according to\n:math:\\mathrm{arctanh} x\nwhile the phase (complex argument) is preserved. This function maps the open unit disc in the complex plane into the entire complex plane: the origin is mapped to itself and the circumference is mapped to infinity.\n:Dimension: As this activation function is applied elementwise, it conserves dimension; the output will be of the same shape as the input.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\ninput\nTensor\nTensor whose amplitude is to be transformed elementwise by the hyperbolic arctangent function.\nrequired\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nout\nTensor\nTransformed input tensor.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "amplitude_atanh"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.amplitude_atanh.html#parameters",
    "href": "api/hypercoil.functional.activation.amplitude_atanh.html#parameters",
    "title": "amplitude_atanh",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\ninput\nTensor\nTensor whose amplitude is to be transformed elementwise by the hyperbolic arctangent function.\nrequired",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "amplitude_atanh"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.activation.amplitude_atanh.html#returns",
    "href": "api/hypercoil.functional.activation.amplitude_atanh.html#returns",
    "title": "amplitude_atanh",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nout\nTensor\nTransformed input tensor.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "amplitude_atanh"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.connectopy.laplacian_eigenmaps.html",
    "href": "api/hypercoil.functional.connectopy.laplacian_eigenmaps.html",
    "title": "laplacian_eigenmaps",
    "section": "",
    "text": "[source]\n\nfunctional.connectopy.laplacian_eigenmaps(\n    W: Tensor\n    k: int = 10\n    normalise: bool = True\n)\nManifold coordinates estimated using Laplacian eigenmaps.\n.. warning::\nSparse inputs are currently unsupported because an implementation of a\nsparse extremal eigenvalue solver does not yet exist in JAX. For\nsparse inputs, use the generalised connectopic functional instead --\nonce we implement VJP rules for elementary operations on sparse\nmatrices, anyway.\n:Dimension: W : :math:(*, N, N) * denotes any number of preceding dimensions, N denotes number of vertices, and E denotes number of edges. Q : :math:(*, N, k) k denotes the number of eigenmaps. L : :math:(*, k) As above.\n\n\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\nDefault\n\n\n\n\nW\ntensor\nEdge weight tensor. If edge_index is not provided, then this should be the graph adjacency (or affinity) matrix; otherwise, it should be a list of weights corresponding to the edges in edge_index.\nrequired\n\n\nk\nint (default 10)\nNumber of eigenmaps to compute.\n10\n\n\nnormalise\nbool (default True)\nIndicates that the Laplacian should be normalised using the degree matrix.\nTrue\n\n\n\n\n\n\n\n\n\nName\nType\nDescription\n\n\n\n\nQ\ntensor\nEigenmaps.\n\n\nL\ntensor\nEigenvalues corresponding to eigenmaps.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "connectopy",
      "laplacian_eigenmaps"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.connectopy.laplacian_eigenmaps.html#parameters",
    "href": "api/hypercoil.functional.connectopy.laplacian_eigenmaps.html#parameters",
    "title": "laplacian_eigenmaps",
    "section": "",
    "text": "Name\nType\nDescription\nDefault\n\n\n\n\nW\ntensor\nEdge weight tensor. If edge_index is not provided, then this should be the graph adjacency (or affinity) matrix; otherwise, it should be a list of weights corresponding to the edges in edge_index.\nrequired\n\n\nk\nint (default 10)\nNumber of eigenmaps to compute.\n10\n\n\nnormalise\nbool (default True)\nIndicates that the Laplacian should be normalised using the degree matrix.\nTrue",
    "crumbs": [
      "`functional`: Functions and functionals",
      "connectopy",
      "laplacian_eigenmaps"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.connectopy.laplacian_eigenmaps.html#returns",
    "href": "api/hypercoil.functional.connectopy.laplacian_eigenmaps.html#returns",
    "title": "laplacian_eigenmaps",
    "section": "",
    "text": "Name\nType\nDescription\n\n\n\n\nQ\ntensor\nEigenmaps.\n\n\nL\ntensor\nEigenvalues corresponding to eigenmaps.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "connectopy",
      "laplacian_eigenmaps"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.cmass.cmass_reference_displacement.html",
    "href": "api/hypercoil.functional.cmass.cmass_reference_displacement.html",
    "title": "cmass_reference_displacement",
    "section": "",
    "text": "cmass_reference_displacement\n\n[source]\n\nfunctional.cmass.cmass_reference_displacement(\n    weight: Tensor\n    refs: Tensor\n    coor: Tensor\n    radius: Optional[float] = None\n)\nDisplacement of centres of mass from reference points – explicit coordinate version.\nSee :func:cmass_coor for parameter specifications.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "cmass",
      "cmass_reference_displacement"
    ]
  },
  {
    "objectID": "api/index.html",
    "href": "api/index.html",
    "title": "API reference",
    "section": "",
    "text": "Functional interfaces for differentiable programming.\n\n\n\nactivation\nAdditional activation functions for neural network layers.\n\n\ncmass\nDifferentiably compute a weight’s centre of mass.\n\n\nconnectopy\nConnectopic manifold mapping, based on brainspace.\n\n\ncov\nEmpirical covariance of variables in a tensor batch.",
    "crumbs": [
      "API reference"
    ]
  },
  {
    "objectID": "api/index.html#functional-functions-and-functionals",
    "href": "api/index.html#functional-functions-and-functionals",
    "title": "API reference",
    "section": "",
    "text": "Functional interfaces for differentiable programming.\n\n\n\nactivation\nAdditional activation functions for neural network layers.\n\n\ncmass\nDifferentiably compute a weight’s centre of mass.\n\n\nconnectopy\nConnectopic manifold mapping, based on brainspace.\n\n\ncov\nEmpirical covariance of variables in a tensor batch.",
    "crumbs": [
      "API reference"
    ]
  },
  {
    "objectID": "api/hypercoil.functional.cmass.cmass_reference_displacement_grid.html",
    "href": "api/hypercoil.functional.cmass.cmass_reference_displacement_grid.html",
    "title": "cmass_reference_displacement_grid",
    "section": "",
    "text": "cmass_reference_displacement_grid\n\n[source]\n\nfunctional.cmass.cmass_reference_displacement_grid(\n    weight: Tensor\n    refs: Tensor\n    axes: Optional[Sequence[int]] = None\n    na_rm: bool = False\n)\nDisplacement of centres of mass from reference points – grid version.\nSee :func:cmass for parameter specifications.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "cmass",
      "cmass_reference_displacement_grid"
    ]
  },
  {
    "objectID": "api/activation.html",
    "href": "api/activation.html",
    "title": "activation",
    "section": "",
    "text": "functional.activation\nAdditional activation functions for neural network layers.\n\n\n\n\n\n\n\n\n\nName\nDescription\n\n\n\n\namplitude_atanh\nInverse hyperbolic tangent (hyperbolic arctangent) activation function applied to the amplitude only.\n\n\namplitude_expbarrier\nExponential barrier activation function applied to the amplitude only.\n\n\namplitude_laplace\nDouble exponential activation function applied to the amplitude only.\n\n\namplitude_tanh\nHyperbolic tangent activation function applied to the amplitude only.\n\n\ncorrnorm\nCorrelation normalisation activation function.\n\n\nexpbarrier\nExponential barrier activation function.\n\n\nisochor\nVolume-normalising activation function for symmetric, positive definite matrices.\n\n\nlaplace\nDouble exponential activation function.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "activation"
    ]
  },
  {
    "objectID": "api/activation.html#functions",
    "href": "api/activation.html#functions",
    "title": "activation",
    "section": "",
    "text": "Name\nDescription\n\n\n\n\namplitude_atanh\nInverse hyperbolic tangent (hyperbolic arctangent) activation function applied to the amplitude only.\n\n\namplitude_expbarrier\nExponential barrier activation function applied to the amplitude only.\n\n\namplitude_laplace\nDouble exponential activation function applied to the amplitude only.\n\n\namplitude_tanh\nHyperbolic tangent activation function applied to the amplitude only.\n\n\ncorrnorm\nCorrelation normalisation activation function.\n\n\nexpbarrier\nExponential barrier activation function.\n\n\nisochor\nVolume-normalising activation function for symmetric, positive definite matrices.\n\n\nlaplace\nDouble exponential activation function.",
    "crumbs": [
      "`functional`: Functions and functionals",
      "activation",
      "activation"
    ]
  }
]